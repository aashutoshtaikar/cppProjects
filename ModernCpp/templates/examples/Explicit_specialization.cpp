/* Template argument deduction and Instantiation
    IMP: If the function template is not invoked, the function is not generated by the compiler
         The Compiler will generate the function for only those types with which it is invoked
         The process of function being generated = instantiation

    1. primary function template definition - header file
    2. Problem with different types and one template argument <typename T>
    3. Explicit declaration which enables Instantiation   - header file
    
    4. Explicit specialization:
    -Problem with primary function template definition causes the addresses of "A" and "B" to be compared
        this is undesirable as we actually want the ASCII values to be compared
        Thus we need to explicitly specialize for that type (const char*)
    -Explicit specialization has to instantiate, thus must be in cpp file and not the header - cpp file
    
 */
#include <iostream>
#include <string.h> //c style strings function: strcmp(x,y);
#include <typeinfo> //typeid()

namespace examples
{
//1. primary function template definition x.h
template<typename T>
T Max(T x, T y){
    std::cout << typeid(T).name() << "\n";
    return x > y ? x : y;
}

//3. Explicit declaration causes instantiation x.h
template 
char Max(char x, char y); 

//4. Explicit specialization y.cpp includes "x.h"
template<>
const char* Max<const char*>(const char* x, const char* y){
    std::cout << "Max<const char*>()\n";
    return strcmp(x,y) > 0 ? x : y;
}

}  //namespace examples

int main() {
    using namespace examples;
    
    //1. Problem with different types
    // Max(3,5.5f); 
    Max(static_cast<float>(3),5.5f);
    Max<double>(3,6.2);
    
    //Even tho, Max() is not being invoked, but because we got its address, compiler instantiates the function template
    int (*pfn)(int,int) = Max;

    
    const char* a{"A"};
    const char* b{"B"};
    auto s = Max(a,b);
    std::cout << s << "\n";

    return 0;
}